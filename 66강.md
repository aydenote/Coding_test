## 66. 블럭탑쌓기

### Q. 탑을 쌓기 위해 각 크기별로 준비된 블럭들을 정해진 순서에 맞게 쌓아야 합니다.

순서에 맞게 쌓지 않으면 무너질 수 있습니다.

예를 들면 정해진 순서가 BAC 라면 A 다음 C가 쌓아져야 합니다.
선행으로 쌓아야 하는 블럭이 만족된 경우라면 탑이 무너지지 않습니다.

- B를 쌓지 않아도 A와 C를 쌓을 수 있습니다.
- B 다음 블럭이 C가 될 수 있습니다.

쌓아져 있는 블럭 탑이 순서에 맞게 쌓아져 있는지 확인하세요.

1. 블럭은 알파벳 대문자로 표기합니다.
2. 규칙에 없는 블럭이 사용될 수 있습니다.
3. 중복된 블럭은 존재하지 않습니다.

입력  
탑 = ["ABCDEF", "BCAD", "ADEFQRX", "BEDFG", "EFGHZ"]  
규칙 = "ABD"

출력  
["가능", "불가능", "가능", "가능", "가능"]

**풀이**

> 예외 처리에 대한 부분이 부족해서 풀지 못한 문제로 유효성
> 체크 함수 내부 동작에 대해 집중하여 학습했습니다.

```
    for (let 부분블록 of 전체블록){
   answer.push(블록순서체크(부분블록, 규칙));
    }
```

> 입력 값인 탑 배열에서 요소 값 하나씩 규칙과 함께 유효성 체크하는 함수 인자로 전달합니다.

```
 let 임시변수 = 규칙.indexOf(규칙[0]);
```

> 규칙 문자열에서 가장 앞에 문자의 인덱스를 임시변수에 저장합니다.

```
 for (let 문자 of 부분블록){
    ...
  }
```

> 탑 배열 요소 하나인 부분블록에서 문자 하나씩 탐색합니다.
> 예를 들어, 'ABCDEF' 가 부분블록이라면 A, B, C, D, ... 문자 하나씩 탐색합니다.

```
if(규칙.includes(문자)){
  if (임시변수 > 규칙.indexOf(문자)){
    return '불가능';
  }
  임시변수 = 규칙.indexOf(문자);
}
```

> 규칙 문자열에 포함된 문자라면 규칙 문자열에서 해당 문자의 인덱스를 찾아 임시변수와 비교합니다. 이전 규칙 문자열에서 문자 인덱스 보다 현재 규칙 문자의 인덱스가 커야 규칙에 맞는 것이기 때문에 임시변수와 규칙 문자열에서의 문자 인덱스를 비교 후 임시변수가 크면 규칙이 안 맞아 바로 불가능을 리턴하고 임시변수가 작으면 임시변수에 현재 규칙 문자열에서의 문자를 저장시키고 다음 문자를 탐색합니다. 그렇게 이전 인덱스 현재 인덱스를 비교했다면 가능을 리턴합니다.

```
function solution(전체블록, 규칙){
  let answer = [];
  for (let 부분블록 of 전체블록){
    answer.push(블록순서체크(부분블록, 규칙));
  }
  return answer;
}

function 블록순서체크(부분블록, 규칙){
  let 임시변수 = 규칙.indexOf(규칙[0]);
  for (let 문자 of 부분블록){
    if (규칙.includes(문자)){
      if (임시변수 > 규칙.indexOf(문자)){
        return '불가능';
      }
      임시변수 = 규칙.indexOf(문자);
    }
  }
  return '가능';
}


const 전체블록 = ['ABCDEF', 'BCAD', 'ADEFQRX', 'BEDFG', 'AEBFDGCH'];
const 규칙 = 'ABC';

console.log(solution(전체블록, 규칙));
```
