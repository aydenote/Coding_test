## 89. 지식이의 게임 개발 2

### Q. (연계형 문제 - 88번을 먼저 풀고 오셔야 합니다!)

제코베의 도움을 받아 성공적으로 지도를 만들어낸 지식이는 캐릭터의 움직임을 구현했습니다.
하지만 지도 위의 캐릭터 위치를 나타내는데 문제가 발생했습니다.
지식이는 지도 위에서 캐릭터의 위치를 나타내기 위해 다시 한번 제코베에 도움을 요청합니다.

지도 위에서 캐릭터의 위치를 나타내주세요

1. 지도는 88번 문제의 해답을 사용해 주세요
2. 입력값은 지도, 캐릭터의 움직임입니다.
3. 캐릭터의 움직임은 { 상:1, 하:2, 좌:3, 우:4 }로 정수로 이루어진 배열이 들어갑니다.
4. 벽과 장애물은 통과할 수 없습니다.
5. 마지막 캐릭터의 위치를 반영한 지도를 보여주고 위치를 반환하는 함수를 작성해 주세요.

데이터
가로 = 4
세로 = 5
캐릭터위치 = [0, 0]
장애물 = [[0,1],[1,1],[2,3],[1,3]]
console.log('캐릭터 이동 전 지도')
지도 = make_map(가로, 세로, 캐릭터위치, 장애물)

움직임 = [2,2,2,4,4,4]
console.log('캐릭터 이동 후 지도')
캐릭터 위치 = move(지도, 움직임)

출력  
캐릭터 이동 전 지도  
[2, 2, 2, 2, 2, 2]  
[2, 1, 2, 0, 0, 2]  
[2, 0, 2, 0, 2, 2]  
[2, 0, 0, 0, 2, 2]  
[2, 0, 0, 0, 0, 2]  
[2, 0, 0, 0, 0, 2]  
[2, 2, 2, 2, 2, 2]

캐릭터 이동 후 지도  
[2, 2, 2, 2, 2, 2]  
[2, 0, 2, 0, 0, 2]  
[2, 0, 2, 0, 2, 2]  
[2, 0, 0, 0, 2, 2]  
[2, 0, 0, 0, 1, 2]  
[2, 0, 0, 0, 0, 2]  
[2, 2, 2, 2, 2, 2]  
캐릭터위치 : [4, 4]  
**풀이**

> 우선, `let 움직인맵 = JSON.parse(JSON.stringify(최초지도));`로 움직이기 전 첫 지도를 깊은 복사하여 움직인 후 지도를 만들었습니다.
> move 함수에서 현 캐릭터 위치의 행렬의 값(인덱스)을 정의하고 switch-case 문으로 상하좌우를 판단하여 캐릭터를 이동시켰습니다. 함수 반환은 움직인맵과 현 캐릭터 위치의 인덱스가 필요하기 때문에 배열로 묶어 반환하였으며, 구조 분해 할당으로 각각 할당 받아 출력하여 풀었습니다.

```
let 가로 = 4;
let 세로 = 5;
let 캐릭터위치 = [0, 0];
let 장애물 = [
  [0, 1],
  [1, 1],
  [2, 3],
  [1, 3]
];
let result = [];
let 움직임 = [2, 2, 2, 4, 4, 4];
function make_map(가로, 세로, 캐릭터위치, 장애물) {
  // 2차원 배열 생성
  for (let i = 0; i < 세로; i++) {
    result[i] = new Array(가로).fill(0);
  }
  // 캐릭터 위치
  result[캐릭터위치[0]][캐릭터위치[1]] = 1;

  // 장애물 생성
  for (let j = 0; j < 장애물.length; j++) {
    result[장애물[j][0]][장애물[j][1]] = 2;
  }

  // 배열의 좌우 벽 생성
  for (let k = 0; k < 세로; k++) {
    result[k].unshift(2);
    result[k].push(2);
  }

  // 배열의 위 아래 벽 생성
  result.unshift(new Array(가로 + 2).fill(2));
  result.push(new Array(가로 + 2).fill(2));

  return result;
}

let 최초지도 = make_map(가로, 세로, 캐릭터위치, 장애물);
let 움직인맵 = JSON.parse(JSON.stringify(최초지도));

function move(움직인맵,움직임) {
  let 움직임배열길이 = 움직임.length;
  let 현위치행 = 1;
  let 현위치열 = 1;
  for (let i = 0; i < 움직임배열길이; i++) {
    let 움직임값 = 움직임.shift();
    switch (움직임값) {
      case 1:
        if (움직인맵[현위치행 - 1][현위치열] !== 2) {
          움직인맵[현위치행][현위치행] = 0
          움직인맵[현위치행 - 1][현위치열] = 1;
          현위치행 -= 1;
        }
        break;
      case 2:
        if (움직인맵[현위치행+1][현위치열] !== 2) {
          움직인맵[현위치행][현위치열] = 0
          움직인맵[현위치행 + 1][현위치열] = 1;
          현위치행 += 1;
        }
        break;
      case 3:
        if (움직인맵[현위치행][현위치열-1] !== 2) {
          움직인맵[현위치행][현위치열] = 0
          움직인맵[현위치행][현위치열-1] = 1;
          현위치열 -= 1;
        }
        break;
      case 4:
        if (움직인맵[현위치행][현위치열+1] !== 2) {
          움직인맵[현위치행][현위치열] = 0
          움직인맵[현위치행][현위치열+1] = 1;
          현위치열 += 1;
        }
        break;
      default:
        break
    }
  }
  return [움직인맵, [현위치행,현위치열]]
}
let [newMap, 인덱스] = move(움직인맵,움직임);
console.log(...최초지도);
console.log(...newMap);
console.log(인덱스);



```
